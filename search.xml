<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Ubuntu下一个接口同时配置静态IP跟dhcp]]></title>
    <url>%2FUbuntu%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%A5%E5%8F%A3%E5%90%8C%E6%97%B6%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81IP%E8%B7%9Fdhcp%2F</url>
    <content type="text"><![CDATA[电脑放公司使用接网线发现只能使用 DHCP 获取动态地址，由于本地测试需要，希望能够配置使用第二个私有的 IP 地址，同时不影响原来 DHCP 获取的 IP。 首先打开接口文件， 1sudo vim /etc/network/interfaces 编辑添加配置，:wq 保存退出。 12345678910auto loiface lo inet loopbackauto enp0s25 # 网卡开机自动挂载iface enp0s25 inet dhcp # enp0s25 配置成 DHCP 动态获取 IPauto enp0s25:0iface enp0s25:0 inet static # enp0s25:0 这里用来配置网卡子接口的静态 IP地址address 192.168.0.53netmask 255.255.255.0 上面 enp0s25 是我的有线网口名称，需要通过 ifconfig 查询改成自己电脑的网口名称。 重启网络服务 1sudo systemctl restart networking.service 通过 ping 验证 IP 是否生效。]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下高效率开发环境搭建]]></title>
    <url>%2FLinux%E4%B8%8B%E9%AB%98%E6%95%88%E7%8E%87%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[入手ThinkPad X250 后，增加了 4G 内存条，128G SSD，安装 Ubuntu 16.04 并使用已经快一年了， 总结下常用的高效率软件。 开发工具VIM目前写 C、Python 代码必备，Java 还是用 IntelliJ IDEA 。安装 YouCompleteMe 插件需要升级到 VIM 8.0 以上。 12345678910git clone https://github.com/vim/vim.git./configure --with-features=huge \ --enable-multibyte \ --enable-rubyinterp=yes \ --enable-python3interp=yes \ --with-python3-config-dir=/usr/lib/python3.5/config \ --enable-perlinterp=yes \ --enable-luainterp=yes \ --enable-gui=gtk2 --enable-cscope --prefix=/usrmake VIMRUNTIMEDIR=/usr/share/vim/vim80 VIM 插件配置自己摸索一段时间后，改成直接参考 k-vim 的配置针对自己的习惯做了些修订，这是我 fork 出来的路径如下 k-vim 。 Tmux终端下分屏利器，插件 tmux-yank 直接拷贝当前输入命令和当前目录。 oh-my-zshIntelliJ IDEA命令行工具mycli连接 MySQL，各种提示补全 SQL 用起来很舒服。 trans谷歌出品的 terminal 端的翻译软件，网易有道词典客户端经常出问题，已放弃，用这个替代。 tldr、cheat经常忘记命令各种参数怎么用，可以用查询常见用法很方便，支持的命令及显示的用法有所不一样，两个结合起来用。 编辑软件TyporaMarkdown 编辑利器，免费，支持 windows/linux，所见即所得，支持 [GitHub Flavored Markdown][GFM]。 Hexo搭建静态 Blog 的工具，使用 NEXT 主题，在命令行下即可生成文档并部署到云端，免费托管在 Github Pages 上面。 Nutstore我是坚果云付费用户，良心产品，支持 Linux ，同步速度快。 Web EvernoteLinux 下印象笔记只能用网页版，个人感觉体验不错，已经可以替代客户端。 Chrome1 12]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言值得注意的地方]]></title>
    <url>%2FC%E8%AF%AD%E8%A8%80%E5%80%BC%E5%BE%97%E6%B3%A8%E6%84%8F%E7%9A%84%E5%9C%B0%E6%96%B9%2F</url>
    <content type="text"><![CDATA[阅读 宋劲杉 老师的 Linux C 编程一站式学习 总结 C 语言的一些特性。 声明和定义声明：变量声明、函数声明、类型声明。 分配存储空间的声明同时也是定义，不分配存储空间的声明不是定义。 凡是被多次声明的变量或函数，必须有且只有一个声明是定义的，如果有多个定义，或者一个定义都没有，链接器就无法完成链接。 定义一个变量，就是分配一块存储空间并给它命名; 给一个变量赋值，就是把一个值保存到这块存储空间。 初始化是一种特殊的声明，而不是一种赋值语句。 表达式任何表达式都用值和类型两个基本属性。 左值右值有些表达式可以表示存储位置和值，有些只能表示值。表达式所表示的存储位置称为左值 (lvalue)，允许放在等号左边，表达式的值称为右值 (rvalue) ，只能放在等号右边。如下 error : 12(a = b) = cminute + 1 = hour; 返回值函数返回一个值相当预定义一个和返回值类型相同的临时变量并用 return 后面的表达式来初始化。 函数返回值不是左值，或者说函数调用表达式不能做左值。 1is_even(20) = 1; /* error */ 转义序列 \n 是在编译时处理，而转换说明在运行时调用 printf 函数处理的。 1printf("character: %c\n", '&#125;'); 整数类型整型：char、int 型 副作用 (Side Effect)改变计算机存储单元⾥的数据或者做输⼊输出操作都算 Side Effect，包括如下几个： 函数有副作用，与数学函数在概念上的根本区别。比如 printf 通常不关心它的返回值，只是利用它所产生的打印的副作用。或者在函数中修改某全局变量也是一种 Side Effect。 赋值运算符，把表达式 a = b 看做函数，返回值既是 a 又是 b 的值，副作用是 a 的值被改变。 前缀或后缀运算符 (++ –)，把表达式 ++i 看作函数调用，传入一个参数返回值等于参数加 1，副作用是 i 的值加 1。 复合赋值运算符 (*= /= %= += -= &lt;&lt;= &gt;&gt;= &amp;= ^= |=)， a += 1 相当于 a = a + 1，但有⼀点细微的差别，前者对表达式 a 只求值⼀次，⽽后者求值两次。 1a[foo()] += 1； a[foo()] = a[foo()] + 1； // 如果 foo() 函数调⽤有Side Effect，⽐如会打印⼀条消息，那么前者只打印⼀次，⽽后者打印两次。 Sequence PointC标准规定代码中的某些点是 Sequence Point，当执⾏到⼀个 Sequence Point 时，在此之前的 Side Effect 必须全部作⽤完毕，在此之后的 Side Effect 必须⼀个都没发⽣。⾄于两个 Sequence Point 之间的多个 Side Effect 哪个先发⽣哪个后发⽣则没有规定，编译器可以任意选择各 Side Effect 的作⽤顺序。如下例子结果 undefined，跟编译器实现相关。 123int a = 0;a = (++a)+(++a)+(++a)+(++a);printf("%d\n", i++ * i++); 包含如下几种 Sequence Point: 调⽤⼀个函数时，在所有准备⼯作做完之后、函数调⽤开始之前是Sequence Point。 1foo(f(), g()); // f() g()执行顺序未知 条件运算符 ?:、逗号运算符、逻辑与 &amp;&amp;、逻辑或 || 的第⼀个操作数求值之后是 Sequence Point。 在⼀个完整的声明末尾是Sequence Point，所谓完整的声明是指这个声明不是另外⼀个声明的⼀部分。 1int a[10], b[20]; // 在 a[10] 末尾是Sequence Point，在 b[20] 末尾也是 在⼀个完整的表达式末尾是Sequence Point，所谓完整的表达式是指这个表达式不是另外⼀个表达式的⼀部分。 1f(); g(); // f()在g()之前先执行 在库函数即将返回时是Sequence Point。 写表达式应遵循的原则： 在两个 Sequence Point 之间，同⼀个变量的值只允许被改变⼀次 。 如果在两个 Sequence Point 之间既要读⼀个变量的值⼜要改它的值，只有在读写顺序确定的情况下才可以这么写。 123a = (++a)+(++a)+(++a)+(++a); // error a[i++] = i; // error i = i + 1; // 读写顺序确定，ok void 设计原因从语法上规定没有返回值的函数调用表达式是 void 类型，有一个 void 类型的值，这样任何表达式都有值，不必考虑特殊情况，编译器的语法解析比较容易; 然后从语义上规定 void 类型的表达式不能参与运算，从而兼顾类语法上的一致和语义上的不矛盾。 运算符优先级后缀运算符包括后缀++、后缀–、结构体取成员.、 数组取下标[]，单目(或前缀)运算符包括前缀++、前缀–、正号+ 、负号-、逻辑非！。后缀运算符优先级最高，单目运算符仅次于后缀，比其它运算符都高。 ++count[2] 是对 count[2] 做前缀 ++ 运算。 数组数组类型做右值使用时，自动转换成指向数组首元素的指针。下面的写法是错误的。 12int a[5] = &#123; 4, 3, 2, 1 &#125;;int b[5] = a; /* error; incompatible types in assignment */ 在函数原型中，如果参数写成数组的形式，则该参数实际上是指针类型。 define 和枚举define 不仅可以定义常量，也可以定义更复杂的语法结构，宏定义，define 定义在预处理阶段处理，枚举在编译阶段处理。 结构体的成员名和变量名不在同一命名空间，枚举的成员名和变量名在同一命名空间。 123456789#include &lt;stdio.h&gt;enum coordinate_type &#123; RECTANGULAR = 1, POLAR &#125;;int main(void)&#123; int RECTANGULAR; printf("%d %d\n", RECTANGULAR, POLAR); /* 2 0 */ return 0;&#125; Old Style C 风格并非所有函数声明包含完整的函数原型，如 12void threelines(); /* 没有指出参数类型和个数 */void main() &#123;&#125; sizeofsizeof 是⼀个特殊的运算符，有两种形式：sizeof 表达式 和 sizeof(类型名) 。 sizeof 表达式 中的⼦表达式并不求值，⽽只是根据类型转换规则求得⼦表达式的类型，然后把这种类型所占的字节数作为整个表达式的值。 sizeof(表达式) 形式⾥的括号和 return(1); 的括号⼀样，不起任何作⽤。 sizeof(类型名) 的括号是必须写的，整个表达式的值也是这种类型所占的字节数。 12int a[12];printf("%d\n", sizeof a/sizeof a[0]);]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C99语言新特性]]></title>
    <url>%2FC99%E8%AF%AD%E8%A8%80%E6%96%B0%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[阅读 宋劲杉 老师的 Linux C 编程一站式学习 后总结 C99 引入的新特性。 声明跟语句顺序C89 要求所有声明写在所有语句之前，而 C99 允许语句和声明按任意顺序排列，只要每个标识符遵循先声明后使用的原则就行。 初始化和赋值复合类型如下例子，C99 中 z1 必须是局部变量才能用另外一个变量 x 的值初始化，如果是全局变量就只能⽤常量表达式来初始化。C89 中不管局部变量还是全局变量都必须常量表达式才能初始化。 12double x = 3.0;struct complex_struct z1 = &#123; x, 4.0, &#125;; /* z1.x=3.0, z1.y=4.0 */ C99引⼊⼀种新的表达式语法Compound Literal可以⽤来赋值，例如 12z1 = (struct complex_struct)&#123; 3.0, 4.0&#125;; // 支持z1 = &#123; 3.0, 4.0&#125;; // 不支持 Designated Initialization初始化稀疏结构体和稀疏数组很方便，结构体或数组中只有某一个或某几个成员需要初始化，其它成员都用 0 初始化，使用这个语法可以很方便的针对某个成员做初始化 (Memberwise Initialization) 。 123456789struct complex_struct &#123; double x, y;&#125; z1, z2;struct complex_struct z1 = &#123; .y = 4.0&#125;; /* 结构，z1.x=0.0, z1.y=4.0 */int count[4] = &#123; [2] = 3 &#125;; /* 数组 */int a[3][2] = &#123; [0][1] = 9, [2][1] = 8 &#125;; /* 多维数组 */struct complex_struct &#123; /* 嵌套方式 */ double x, y;&#125; a[4] = &#123; [0].x = 8.8 &#125;; 变长数组 (Variable Length Array, VLA)正常数组类型的长度用一个整数常量表达式来指定。C99 允许在数组长度表达式中使用变量，称为变长数组。只能定义为局部变量而不能是全局变量。 循环C99规定了⼀种新的 for 循环语法，在控制表达式1的位置可以有变量定义。从C++借鉴的。 123for (int i = 0; i &lt; 10; i++) &#123; //i是循环的局部变量，不是函数的局部变量 ;&#125; 关键字 C99 引入内联函数 (inline function)，inline 告诉编译器函数调用要尽量快，可以当普通函数调用，也可以当做宏展开来实现。 C99 定义了专门的布尔类型 _Bool。 restrict 告诉编译器可以放⼼地对这个函数做优化，程序员⾃⼰会保证这些指针所指的内存区间互不重叠。 1void *memcpy(void * restrict s1, const void * restrict s2, size_t n); // 不允许优化 杂 C99 借鉴 C++ 引入单行注释 // comment。 C99 引⼊⼀个特殊的标识符 __func__ ⽀持这⼀功能。这个标识符应该是⼀个变量名⽽不是宏定义，不属于预处理的范畴，但它的作⽤和 __FILE__ 、 __LINE__ 类似。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机编程思想总结]]></title>
    <url>%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[宋劲杉 老师的 Linux C 编程一站式学习 是国人当中写的非常好的计算机书籍，豆瓣评分 9.3 ，非科班出生的程序员拿来入门非常好，后面部分关于程序原理的内容也适合工作多年的人进行查缺补漏。书籍囊括了程序设计基本思想和开发调试方法，以 Linux 平台为载体介绍 C 语言基础及程序工作原理，Linux 系统编程，对计算机组成、C 语言、操作系统、编译原理等课程知识达到融汇贯通。很难得图书还是开源的，链接 http://akaedu.github.io/book/index.html， 第二版 一站式学习 C 编程 删掉了 Linux 系统编程相关的内容，其它变化不大，推荐第一版。这篇总结图书中提到的编程思想及相关思维方法。 编程学习基本类型和复合类型 Primitive Type：最基本的的、不可再分的数据类型 Compound Type：根据语法规则组合而成的类型 学习编程要注意的三个方面（来自SICP） 提供的了哪些 Primitive，如基本类型、基本运算符、表达式、语句。 提供了哪些组合规则，如基本类型怎么组合成复合类型，简单表达式和语句怎么组成负杂的表达式和语句 提供了哪些抽象机制，包括数据抽象和过程抽象。 思维方法以概念为中心的阅读习惯每读一节就总结一套概念之间的关系图。比如下面的概念： 程序由指令组成，计算机只能执行低级语言的指令，高级语言执行前要先编译或解释，好处是平台无关性，平台是一种体系结构，是一种指令集，就是一种机器语言。 编程语言是一种形式语言，对应人类用的自然语言，形式语言有严格的语法 (Syntax) 规则，由符号 (Token) 和结构(Structure) 的规则组成。关于 Token 的规则称为词法 (Lexical) 规则，关于结构的规则称为语法 (Grammer)规则。分析句子结构的过程称为解析 (Parse)。解析完句子，理解句子的上下文，暗示的内容，是语义 (Semantic) 的范畴。形式语言和自然语言的区别：歧义性、冗余性、与字面意思的一致性。 最少例外原则 (Rules of Least Surprise)一个容易被用户接受的设计应该遵循最少例外原则。C 语言的设计非常优美，C++ 的设计非常负责，充满例外，饱受争议。 必要条件 (Necessary Condition)和充分条件 (Sufficient Condition)不要把必要条件当充分条件。 编程思想组合规则 (Composition)组合规则是理解语法规则的基础，根据语法规则任意组合，可以用简单的常量、变量、表达式、语句和声明搭建出任意复杂的程序。 递归 (Recursive) 和 迭代 (Iteration)如果定义一个概念要用到这个概念本身，它的定义是递归的。需要定义一个最关键的基础条件 (Base Case)，比如阶乘 (Factorial) 里 0 的阶乘等于 1。如果你相信你正在写的递归函数是正确的，并调用它，然后在此基础上写完这个递归函数，那么它就会是正确的，从而值得你相信它正确。 每次都有一点区别的重复工作称为迭代。 递归和循环是等价的，用循环能做的事用递归都能做，比如 LISP 语言只有递归而没有循环，编译器的实现用了大量递归。 递归例子：两个正整数的 a 和 b 的最大公约数 (GCD, Greatest Common Divisor) 使用 Euclid 算法，如果 a 除以 b 能整除， 则最大公约数是 b，否则，最大公约数等于 b 和 a%b 的最大公约数。 无限循环 (Infinite Loop) 的例子，n 忽大忽小，著名的 3+1 问题： 1234567while (n != 1) &#123; if (n % 2 == 0) &#123; n = n / 2; &#125; else &#123; n = n * 3 + 1; &#125;&#125; 函数式编程 (Functional Programming) 和命令式编程 (Imperative Programming)函数式思路：整个递归调用过程中，虽然分配和释放了很多变量，但所有变量都只在初始化时赋值。 命令式思路：通过循环对变量多次赋值来达到同样的目的。C 语言主要用 Imperative 的方式。 抽象 (Abstraction)组合使得系统可以任意复杂，而抽象使得系统的复杂性是可以控制的，任何改动都局限在某一层，而不会波及整个系统。计算机科学家 Butler Lampson 说过：&quot;All problems in computer science can be solved by another level of indirection.&quot; 避免硬编码 (Hard coding)数据驱动的编程 (Data-driven Programming)数据代替代码，以打印星期几的代码为例：通过下表访问字符串组成的数组可以代替一堆 case 分支判断，把每个 case 里重复的代码 (printf 调用)提取出来。写代码最重要的是选择正确的数据结构来组织信息，设计控制流程和算法尚在其次，只要数据结构选择正确，其它代码自然而然变得容易理解和维护。Show me your flowcharts and conceal your tables, and I shall continue to be mystified. Show me your tables, and I won&#39;t usually need your flowcharts, they&#39;ll be obvious. 分而治之 (Divide-and-Conquer)举例，归并排序，时间复杂度O(nlgn)： Divide: 把长度为 n 的输入序列分成两个长度为 n/2 的子序列 Conquer: 对两个子序列分别采用归并排序 Combine: 将两个排序好的子序列合并成一个最终的排序序列 折半查找 (Binary Search)针对有序序列，每次把搜索范围缩小一半。 回溯 (Backtrack)探索问题的解时走进了死胡同，则需要退回来从另一条路继续探索。举例：基于堆栈的深度优先搜索 (DFS, Depth First Search)。 调试方法错误编译时错误、运行时错误 (Run-time) 、逻辑和语义错误。 增量式 (Incremental) 开发首先分析和分解问题，把大问题分解成小问题，再对小问题分别求解。这个过程在代码中体现函数的分层设计 (Stratify) ，底层函数解决小问题，上层函数通过调用底层函数解决更大的问题。 插入排序算法采用增量式的策略解决问题，每次添一个元素到已排序的子序列中，逐渐将整个数组排序完毕。时间复杂度O(n^2)。 打印语句函数里的 printf 语句类似脚手架 (Scaffold)，验证无误后就可以撤掉。把 Scaffolding 的代码注释掉。 Design by Contract (DbC)如果每个函数的文档都非常清楚地记录 Precondition、Maintenance、Postcondition 是什么，每个函数都可以独立编写和测试。 断言 (Assertion)发布时在包含 assert.h 之前定义一个 NDEBUG 宏，就可以禁用 assert.h 中的 assert 宏定义，或者编译时加上选项 -DNDEBUG 。 杂 switch 的语句块和循环结构的语句块没有本质区别：Duff’s Device 。 编码风格 Thus, programs must be written for people to read, and only incidentally for machines to execute.]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>编程思想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[打开浏览器输入URL时发生了哪些事]]></title>
    <url>%2F%E6%89%93%E5%BC%80%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5URL%E6%97%B6%E5%8F%91%E7%94%9F%E4%BA%86%E5%93%AA%E4%BA%9B%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[一道经典的问题，考察对操作系统、网络、web 开发等知识。作为一个网络软件这块的开发人员，一直有兴趣总结下这方面知识，正好最近看了日本作家户根勤写的 网络是怎样连接的 ，补足我不少盲点，该书豆瓣评分 9.1，推荐阅读。这篇文章总结该书的关键知识点，并加入自己的理解。 总览 ​ 以 Linux 客户端及服务器为例： 在浏览器地址栏敲击键盘输入 URL，按下回车。 浏览器对输入的 URL 进行拆分解析，得到scheme:location:path:query:fragment，scheme 是 http 或者https 的走 HTTP 协议，location 一般是域名。 假设 location 是域名，浏览器首先查询本地主机缓存，如果找到对应域名的 IP 地址返回。如果没找到，发起DNS 域名解析请求得到 IP。 得到服务器 IP 地址后，浏览器发起 HTTP 请求，一般是 GET 方法，请求路径 path 下的资源。 HTTP 协议构造 request 报文，调用协议栈接口创建 TCP socket，传入连接的服务器端的 IP 跟端口，TCP 协议栈随机分配一个源端口，构造 TCP 报文，经过跟服务器的 TCP 三次握手建立起连接。 request 报文中间经过交换机、路由器、防火墙、代理等设备转发到达服务器，服务器端应用服务器解析报文得到请求的资源，如果是静态资源，直接访问对应路径下的文件构造 Response 回复给浏览器。如果是动态资源，经过路由传给运行的脚本语言处理，通过查数据库、计算等操作构造返回的数据，内容传给模板引擎转化为 HTML 格式，最终 Response 调用 HTTP 协议接口回复给客户端。 浏览器端收到 Response 里具体数据后进行渲染显示，如果 HTML 内还包含 img、js 等路径，浏览器会接着发起获取这些静态资源的请求。 浏览器经过 TCP 4次挥手断开与服务器端的连接。 TCP 三次握手 客户端创建 Socket 时，系统分配一个描述符进行标识，应用程序是通过描述符区分不同的套接字。 套接字中记录了用于控制通信操作的各种控制信息，协议栈则需要根据这些信息判断下一步的行动。netstat -anp 可查看这些信息。 客户端进行 connect 时发起连接，连接实际是通信双方交换控制信息，传入目的服务器 IP 跟端口，IP跟端口是识别对方套接字的机制，TCP 模块创建 TCP 头部信息，这时协议栈发送 SYN 控制位置 1 的 TCP 报文，同时序号以随机值作为初始值告诉服务器端。 服务器端预先创建好 socket，绑定监听的地址跟端口开始监听，当收到客户端的 SYN 报文时，记录客户端的IP 跟源端口，TCP 模块根据报文目的 IP 及 目的端口找到对应的 socket，并回复 SYN，ACK 控制位置 1 的报文。 客户端收到报文后回复 ACK 控制位置 1 的报文，跟服务器建立起连接，可以随时收发数据。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>networking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lorawan基站开发]]></title>
    <url>%2Flora%E5%9F%BA%E7%AB%99%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[这篇文章主要记录lora原型基站开发的过程，基站支持对接市场上默认的 LoRaWAN Server，支持有线口回传，支持4G回传。 架构 步骤 CPU 移植运行 OpenWRT 系统，有线口正常，这块我是基于现成的，此处省略 调试 SX1301 芯片驱动 移植 Semtech 公司开源的 packet_forwarder 到 OpenWRT 平台，对接通用的 LoRaWAN Server 调试移植4G模块驱动 硬件组成：CPU 使用 SOC AR95xx 系列芯片，通过 SPI 接口跟基带芯片通信，LoRa 基带射频使用 Semtech 公司的多路芯片 SX1301 + SX1255，4G 模组使用龙尚 U8300 软件：平台 OpenWRT ，版本 Attitude Adjustment 12.09，内核 3.3.8 报文流程 AR95xx 通过 HAL 模块的 SPI 读写操作控制 SX1301 接收终端发送的报文，经过 packet forwarder 模块封装打包后走有线口、WIFI 或 4G 通路，通过UDP方式发送给后台 LoRaWAN Server LoRa 芯片驱动调试AR9531 可以通过 USB 或 SPI 驱动 SX1301，USB方式需要FTDI转 SPI 芯片方式网上教程较多。由于板子限制，这里采用 SPI 方式，由于板子的 SPI 控制器已经用来驱动 flash，控制 SX1301 有两种方式： GPIO 模拟 SPI 来控制（软 SPI ） 实际的硬件 SPI 通过片选控制 为提高调试效率，先修改Makefile的 cmdline 字段波特率，以串口 ttyS0 为例下面命令可以查找包含 ttyS0 对应行，使用 VIM 修改成 115200。 1grep ttyS0 ./target/linux/ar71xx/image/Makefile GPIO 模拟 SPI 参考 https://randomcoderdude.wordpress.com/2013/08/15/spi-over-gpio-in-openwrt/ GPIO 管脚使用 先确认 GPIO 管脚是否可用，是否能拉高拉低 123456789cat /sys/kernel/debug/gpio # 查看 GPIO 调试信息cd /sys/class/gpio echo 2 &gt; export # 把 GPIO 管脚 2 导出到用户空间cd gpio2echo out &gt; direction # 配置成输出echo 0 &gt; value # 输入值 0cat value # 查看值是否改变echo 1 &gt; value # 输入值 1cat value ​ 如果CPU用到对应 GPIO 口存在 JTAG 复用的话，芯片初始化 GPIO 时把 JTAG 关掉1234//文件：linux-3.3.8/arch/mips/ath79/gpio.c//函数：ath79_gpio_initif (soc_is_qca953x()) ath79_gpio_function_enable(AR934X_GPIO_FUNC_JTAG_DISABLE); 移植编译内核模块 OpenWRT 内核默认就已经有 GPIO 模拟 SPI 的驱动模块（spi-gpio、spi-bitbang），另外有spi-dev 设备层通用驱动，用来导出到用户空间，编译内核前把这三个模块打开。spi-dev 模块问题是不大方便调试，建议下载移植 spi-gpio-custom 模块用于动态加载软 SPI 模块，根据对应 GPIO 管脚加载。 123456789101112131415161718# 参数说明* bus0 These four arguments can be arrays of* bus1 1-8 unsigned integers as follows:* bus2* bus3 &lt;id&gt;,&lt;sck&gt;,&lt;mosi&gt;,&lt;miso&gt;,&lt;mode1&gt;,&lt;maxfreq1&gt;,&lt;cs1&gt;,...* where:** &lt;id&gt; ID to used as device_id for the corresponding bus (required)* &lt;sck&gt; GPIO pin ID to be used for bus SCK (required)* &lt;mosi&gt; GPIO pin ID to be used for bus MOSI (required*)* &lt;miso&gt; GPIO pin ID to be used for bus MISO (required*)* &lt;modeX&gt; Mode configuration for slave X in the bus (required)* (see /include/linux/spi/spi.h)* &lt;maxfreqX&gt; Maximum clock frequency in Hz for slave X in the bus (required)* &lt;csX&gt; GPIO pin ID to be used for slave X CS (required**)insmod spi-gpio-custom bus0=1,14,15,16,0,1000000,4 # 加载模块ls /dev/ | grep spidev1.0 # 确认 spidev 设备是否出现，存在则加载成功 ​ 硬件SPI片选控制待完善，主要修订代码 dev-m25p80.c， 12345678910111213141516171819202122232425262728293031323334353637383940+static struct ath79_spi_controller_data ath79_spi_cdata0 =+&#123;+ .cs_type = ATH79_SPI_CS_TYPE_INTERNAL,+ .cs_line = 0,+&#125;;++static struct ath79_spi_controller_data ath79_spi_cdata1 =+&#123;+ .cs_type = ATH79_SPI_CS_TYPE_GPIO,+ .cs_line = 2,+ .is_flash = false+&#125;;++static struct spi_board_info ath79_spi_info_multi[] = &#123;+ &#123;+ .bus_num = 0,+ .chip_select = 0,+ .max_speed_hz = 25000000,+ .modalias = "m25p80",+ .controller_data = &amp;ath79_spi_cdata0,+ &#125;,+ &#123;+ .bus_num = 0,+ .chip_select = 1,+ .max_speed_hz = 25000000,+ .modalias = "spidev",+ .controller_data = &amp;ath79_spi_cdata1,+ &#125;+&#125;;++void __init ath79_register_m25p80_multidev(struct flash_platform_data *pdata)+&#123;+ multi_pdata = pdata;+ add_mtd_concat_notifier();+ ath79_spi_data.bus_num = 0;+ ath79_spi_data.num_chipselect = 2;+ ath79_spi_cdata0.is_flash = false;+ ath79_spi_info_multi[0].platform_data = pdata;+ ath79_register_spi(&amp;ath79_spi_data, ath79_spi_info_multi, 2);+&#125; LoRa转发模块移植 编译移植 LoRa 报文转发模块 下载编译 packet_forwarder 、lora_gateway 模块，lora_gateway 编译时生成 .a 库文件，供 packet_forwarder 模块调用运行报文转发程序，根据自己系统修改下 Makefile，编译完生成 lora_pkt_fwd 可执行文件以及其他测试程序。 https://github.com/Lora-net/packet_forwarder https://github.com/Lora-net/lora_gateway Note：模块 v3.0.0 版本对接 LoRaWAN Server 使用了自定义的 GWMP 协议版本 2，不兼容版本 1，对接时要注意两边版本一致 编写 packet_forwarder 起机脚本，包含了加载软 SPI 模块，复位 SX1301（手册要求），更新 local_conf 网关 MAC，启动 LoRa 转发模块，参考如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#!/bin/sh /etc/rc.commonSTART=101STOP=102insmod_gpio_custom=truereset_lora_chip=truereset_cmd="reset_lgw.sh"upgw_cmd="update_gwid.sh"cmd="lora_pkt_fwd"mod="spi-gpio-custom"configFile="local_conf.json"gpio_spi_dev="/dev/spidev1.0" # gpio simulated driverhard_spi_dev="/dev/spidev0.1" # alternative: controlled by hardware spi controllerpid_file="/var/run/$cmd.pid"stdout_log="/tmp/$cmd.log"#stderr_log="/tmp/$cmd.err"sck_pin=14mosi_pin=15miso_pin=16mode=0max_freq=10000000cs_pin=4get_pid() &#123; ps | grep -v grep | grep "$cmd" | awk '&#123;print $1&#125;'&#125;is_running() &#123; ps | grep -v grep | grep "$cmd" &gt; /dev/null [ $? = 0 ]&#125;start() &#123; if is_running; then echo "Already started" else if [ \( ! -e "$gpio_spi_dev" \) -a \( ! -e "$hard_spi_dev" \) ]; then echo "insmod custom gpio based spi" insmod $mod bus0=1,$sck_pin,$mosi_pin,$miso_pin,$mode,$max_freq,$cs_pin # 可以在代码里加载好 fi if [ "$reset_lora_chip" = true ]; then echo "Reset SX1301" chmod +x /etc/lora/"$reset_cmd" /etc/lora/"$reset_cmd" start fi echo "update gateway id" chmod +x /etc/lora/"$upgw_cmd" /etc/lora/"$upgw_cmd" /etc/lora/"$configFile" echo "Starting $cmd" /usr/sbin/"$cmd" # &gt;&gt; "$stdout_log" 2&gt;&gt; "$stdout_log" &amp; echo "$!" &gt; "$pid_file" if ! is_running; then echo "Unable to start, see $stdout_log" exit 1 else echo "Successfully started, see $stdout_log" fi fi&#125;stop() &#123; if is_running; then echo -n "Stopping $cmd.." kill `get_pid` for i in &#123;1..60&#125; do if ! is_running; then break fi echo -n "." sleep 1 done echo sleep 1 if [ "$reset_lora_chip" = true ]; then /etc/lora/$reset_cmd stop fi if [ -e "$gpio_spi_dev" ]; then echo "rmmod custom gpio based spi" rmmod $mod fi if is_running; then echo "Not stopped; may still be shutting down or shutdown may have failed" exit 1 else echo "Stopped" if [ -f "$pid_file" ]; then rm "$pid_file" fi fi else echo "Not running" fi&#125;restart() &#123; stop "$@" start "$@"&#125;status() &#123; if is_running; then echo "Running" else echo "Stopped" exit 1 fi&#125;EXTRA_COMMANDS="status"EXTRA_HELP=" status Print the status of lora packet-forward" 1/etc/init.d/packet_forwarder start # 启动 运行测试程序 Note: 运行测试程序前需先加载 spi-gpio-custom 模块，可以启动一下 /etc/init.d/packet_forwarder start 关掉，或者手动加载模块 1234# 发送功率测试，参数根据要求配置util_tx_continuous -f 433.3 -r 1255 --mod LORA --sf 7 --bw 125# 接收灵敏度测试util_rx_test -c /etc/lora/freq_conf_433.json 对接 LoRaWAN Server 只是原型的话推荐接入 Loriot.io 社区进行调试期间试用， https://cn1dashboard.loriot.io/login，也可以自己到 github 上查找开源相关自己搭建一个。 有线口回传 参考 https://wiki.openwrt.org/doc/uci/network 注意与 4G 回传二选一来配置，ping 不通时，注意查看路由表默认路由是否是4G端口 route -e，DNS 要配，LoRa 报文转发模块默认会解析 server 域名。 123456uci set network.lan.proto=static # 静态IPuci set network.lan.ipaddr=xxx.xxx.xxx.xxxuci set network.lan.gateway=xxx.xxx.xxx.xxxuci set network.lan.dns=xxx.xxx.xxx.xxxuci set network.lan.netmask=255.255.255.0uci commit 或者通过改配置文件 /etc/config/network 123456789config interface 'lan' option ifname 'eth0 eth1 ath0' option type 'bridge' # 桥模式 option force_link '1' option proto 'static' option ipaddr 'xxx.xxx.xxx.xxx' option netmask '255.255.255.0' option gateway 'xxx.xxx.xxx.xxx' option dns 'xxx.xxx.xxx.xxx' 重启网络生效 1/etc/init.d/network restart 4G模块调试 参考https://wiki.openwrt.org/doc/recipes/3gdongle http://blog.csdn.net/qianguozheng/article/details/505437044G网卡的拨号方式有三种: PPP (PPP over EV-DO, CDMA, UMTS or GPRS)，QMI (USB modems using QMI protocol)，NCM (USB modems using NCM rotocol) 配置编译使用驱动程序及工具，通过 make menuconfig 里要打开如下模块。 工具comgt USB HCIkmod-usb2 (aka EHCI)kmod-usb-ohcikmod-usb-uhci (for example VIA chips) 虚拟串口通信用kmod-usb-serial, and kmod-usb-serial-option, and kmod-usb-serial-wwan, or kmod-usb-acm 依赖库kmod-usb-core, already in 10.03 RC3 Imagechat, dependency of comgtppp, dependency of chat, already in 10.03 RC3 Imagekmod-usb-serial, dependency of kmod-usb-serial-option option 驱动加载后，出现 5 个 ttyUSB，PPP 拨号使用 ttyUSB1，AT 命令查询 ttyUSB2，数据通路走 PPP 或 QMI 拨号，两者都要修订代码 option_ids 增加 id，芯片初始化要注册USB控制器。 123//文件：linux-3.3.8/arch/mips/ath79/mach-ap120-h.c//函数：static void __init xxx_setup(void)ath79_register_usb(); 12//文件：linux-3.3.8/drivers/usb/serial/option.c&#123; USB_DEVICE(LONGSUNG_VENDOR_ID, LONGSUNG_U8300_PRODUCT_ID)&#125;, /* add for longsung U8300 LTE modem */ PPP 拨号速率支持不是最高，当前状态下够用，3.3.8 内核配置完就可支持，通过 UCI 命令配置1234567uci set wan.ifname=ppp0uci set wan.device=/dev/ttyUSB1uci set wan.apn=3gnetuci set wan.service=umtsuci set wan.dialnumber=*99#uci set wan.proto=3guci set wan.defaultroute=1 或者修改 /etc/config/network 增加 ppp0 的 wan 口 12345678config interface 'wan' option ifname 'ppp0' option device '/dev/ttyUSB1' option apn '3gnet' # 根据运营商变化注：联通apn：3gnet 电信apn：ctnet 移动apn：cmnet/cmwap option service 'umts' option dialnumber '*99#' # 联通dialnumber：3G为*99# 电信：3G为#777 移动为：*99***1# LTE为：*99# option proto '3g' option defaultroute '1' /etc/init.d/network restart 重启网络 ifconfig 查看是否出现 3G 端口 QMI拨号跟 PPP 拨号二选一， 修改代码跳过第四接口不让其被 option 驱动检测到，加载 GobiNet 模块驱动该口，支持 4G，更高速率，使用时 PPP 拨号要关掉 12345678//文件：drivers/usb/serial/option.c//函数： static int option_probe(struct usb_serial *serial, const struct usb_device_id *id)if (cpu_to_le16(serial-&gt;dev-&gt;descriptor.idVendor) == LONGSUNG_VENDOR_ID &amp;&amp; cpu_to_le16(serial-&gt;dev-&gt;descriptor.idProduct) == LONGSUNG_U8300_PRODUCT_ID &amp;&amp; serial-&gt;interface-&gt;cur_altsetting-&gt;desc.bInterfaceNumber == 4) &#123; printk(KERN_INFO"Discover the 4th interface for U8300 NDIS\n"); return -ENODEV;&#125; Gobi 芯片是高通开发的移动宽带 modem，3.3.8 内核需自己移植 GobiNet 驱动，3.4 内核以上系统自身有带 qmi_wwan 驱动，用户空间工具 ofono, uqmi and libqmi，感兴趣的可以看下 https://sigquit.wordpress.com/2014/06/11/qmiwwan-or-gobinet/ 123456789101112131415161718192021222324252627#加载模块insmod /lib/modules/3.3.8/GobiNet.ko#读返回结果cat /dev/ttyUSB2 &amp;#拨号echo -e 'at$qcrmcall=1,1\r\n' &gt; /dev/ttyUSB2#查看出现4g用接口ifconfig #查询网络服务类型echo -en "at+psrat\r" &gt; /dev/ttyUSB2#查询手机功能echo -e "at+cfun?\r" &gt; /dev/ttyUSB2#查询pin是否正常识别或是否有pin码echo -e "at+cpin?\r" &gt; /dev/ttyUSB2#查询运营商echo -e "at+cops?\r" &gt; /dev/ttyUSB2#返回IMSI号echo -en "at+cimi\r" &gt; /dev/ttyUSB2#查询IMEI号echo -e "at+cgsn\r" &gt; /dev/ttyUSB2#查询集成电路卡识别码echo -e "at+iccid\r" &gt; /dev/ttyUSB2#查询信号质量，返回rssi,rxlevelecho -e "at+csq\r" &gt; /dev/ttyUSB2 #断开连接echo -e 'at$qcrmcall=0,1\r\n' &gt; /dev/ttyUSB2 参考除了前面提到了，下面罗列一些关于 LoRaWAN 系统搭建可能会用到的代码链接。 基站端 Low-cost LoRa gateway with SX1272 and Raspberry https://github.com/CongducPham/LowCostLoRaGw This is a fork with the needed modifications to be able to use lora_gateway with a Multitech MTAC-LORA (MultiConnect mCard) board instead of a IoT Starter Kit platform.https://github.com/mirakonta/lora_gateway 模组 Semtech 开源的节点实现代码，MCU基于STM32L151CB，射频SX1272https://github.com/Lora-net/LoRaMac-node IBM 开源的节点实现代码，BSD License，支持ClassA、Bhttps://www.research.ibm.com/labs/zurich/ics/lrsc/lmic.html LoRaWAN Serverlorawan server开源实现，MIT授权，可以参考实现 go语言 the things network社区，15年10月就开始做了，比较完整https://github.com/TheThingsNetwork/ttnV1版本源码：https://github.com/TheThingsNetwork/ttn/tree/v1-stagingTTN官网：https://www.thethingsnetwork.orgTTN架构：https://www.thethingsnetwork.org/wiki/Backend/Overviewttnctl CLI：https://www.thethingsnetwork.org/docs/current/cli/后台：https://account.thethingsnetwork.org go语言，16年2月开始做的，跟TTN很像https://github.com/brocaar/loraserver/ erlang语言，适合小型网络使用，只有1个人在开发https://github.com/gotthardp/lorawan-server Simulationhttps://sites.google.com/a/wesdec.be/mweyn/lpwan Semtech Starter Kithttp://semtechlorakit.blogspot.jp/]]></content>
      <categories>
        <category>嵌入式开发</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>lora</tag>
        <tag>OpenWRT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo blog搭建]]></title>
    <url>%2Fhexo-blog%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[安装部署安装nvm nodejs https://github.com/creationix/nvm 12345curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.6/install.sh | bashexport NVM_DIR="$HOME/.nvm"[ -s "$NVM_DIR/nvm.sh" ] &amp;&amp; . "$NVM_DIR/nvm.sh" # This loads nvmnvm install nodenvm use 9.0.0 安装运行hexo1234567npm install -g cnpm --registry=https://registry.npm.taobao.org #淘宝定制命令cnpm替换，使用淘宝源cnpm install hexo-cli -ghexo init blogcd blogcnpm installhexo server --debug # 运行 自动部署github12345678910npm install hexo-deployer-git --save在配置文件_config.xml中作如下修改deploy: type: git repo: git@github.com:hgleagle/hgleagle.github.io.git branch: masterhexo clean #先清除hexo generate #生成静态文件hexo deploy # 部署，实现如下命令 deploy实际实现如下工作12345cp -R public/* .deploy_git/cd .deploy_gitgit add .git commit -m “update”git push origin master 注册绑定自定义域名namesilo 注册申请域名，只需要 35 块，赠送 whois 隐私保护到 dnspod 绑定域名服务器，创建两个 A 绑定 IP，一个 CNAME 记录绑定域名https://www.namesilo.com/create_account.php 配置配置站点 _config.yml 使用next主题 基础配置参考 http://theme-next.iissnan.com/ #### 文章目录显示npm i hexo-generator-json-content –save 标签云, 分类12hexo new page tagshexo new page categories 评论注册添加disqus12disqus: shortname: https-hgleagle-github-io # 修改next/_config.yml RSS1cnpm install hexo-generator-feed avatar、qrcode使用七牛图床，或者本地在 source 下创建 img 目录保存图片，修改_config.yml添加外链或路径 阅读次数注册leancloud 帐号，创建 Counter ，拷贝 appid、appkey 到下面配置, 安全中心添加 web 安全域1234leancloud_visitors: enable: true app_id: xxx app_key: xxx 搜索123456789# 安装npm install --save hexo-generator-search# 修改站点_config.yml增加search: path: search.xml field: post format: html limit: 10000 Sitemap for SEO 参考Hexo-NexT-主题的-SEO优化Hexo博客收录百度和谷歌-基于Next主题 生成 sitemap 提交到 google、 baidu 进行站点验证，修改配置文件1234567891011# 安装cnpm install hexo-generator-sitemapcnpm install --save hexo-generator-baidu-sitemap# 修改站点config# 提交给谷歌搜素引擎，SEO优化开启配置是一样的sitemap: path: sitemap.xml# 提交百度搜索引擎 baidusitemap: path: baidusitemap.xml 通过搜索引擎查找 site:jasonfly.me 检查是否被收录 添加 robots.txt 协议 修改 next 主题 siderbar.swig footer.swig 增加 rel=&quot;external nofollow&quot;，意思是告诉引擎这些是外链，不要爬取 默认 permalink 太长，缩短成 :title 修改 scaffolds 中 post.md 模板增加 keywords: description: TODO]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
